[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://supermanzer.github.io/DendronNotes/notes/403.html","relUrl":"notes/403.html"},{"doc":"Manzer's Notes","title":"Manzer's Notes","hpath":"root","content":"\n# Manzer Notes\n\nDendron root node for note vautls. The notes below will attempt to follow general project stucture but I suffer the same viscisitudes as many other creative invdividuals who have more ideas than they have space or time to place them in.\n\n## Projects\n\n- [LocaLibrary](https://github.com/supermanzer/NuxtDRFMDN) - A simple but complete full-stack web application replicating a local library site for patrons. It uses Django & DRF for the back-end and Nuxt.js for the front-end.\n","url":"https://supermanzer.github.io/DendronNotes","relUrl":"/"},{"doc":"Local Library","title":"Local Library","hpath":"localibrary","content":"\n[[#topic|tag.topic]]\n\n![Github Logo](/images/github.png) [Github Repo](https://github.com/supermanzer/NuxtDRFMDN)\n\nThis project is a playground of sorts for various ideas and technologies I am curious about implementing in a web application. Often times I will find myself working through a tutorial while learning some new tech and find myself curious about how I would integrate it into a larger project. One of the points of developing the **Local Library** application is to have that larger project into which I can attempt to insert various technologies and application workflows I am curious about.\n","url":"https://supermanzer.github.io/DendronNotes/notes/c49bdcee-daa2-4b8d-af33-af74f37173f0.html","relUrl":"notes/c49bdcee-daa2-4b8d-af33-af74f37173f0.html"},{"doc":"Models","title":"Models","hpath":"localibrary.models","content":"\n","url":"https://supermanzer.github.io/DendronNotes/notes/ecde1434-0562-43bb-855b-fc9c7c5a4f29.html","relUrl":"notes/ecde1434-0562-43bb-855b-fc9c7c5a4f29.html"},{"doc":"Book Instance and Borrowed Copy Models","title":"Book Instance and Borrowed Copy Models","hpath":"localibrary.models.copy_borrowed","content":"\n```python\nclass BookInstance(models.Model):\n    \"\"\"Model representing a specific copy of a book\"\"\"\n    # CONSTANTS - I FIND THIS APPROACH USEFUL EVEN THOUGH IT SEEMS REDUNDANT\n    MAINTENANCE = 'm'\n    ON_LOAN = 'o'\n    AVAILABLE = 'a'\n    RESERVED = 'r'\n\n    LOAN_STATUS = (\n        (MAINTENANCE, 'Maintenance'),\n        (ON_LOAN, 'On loan'),\n        (AVAILABLE, 'Available'),\n        (RESERVED, 'Reserved')\n    )\n    # FIELDS\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4,\n                          help_text='Unique ID for particular book')\n    book = models.ForeignKey(\n        'Book', on_delete=models.RESTRICT, related_name='instances')\n    imprint = models.CharField(max_length=200)\n    due_date = models.DateField(null=True, blank=True)\n    status = models.CharField(max_length=1, choices=LOAN_STATUS,\n                              blank=True, default=MAINTENANCE, help_text='Book availability')\n    # Meta options\n\n    class Meta:\n        verbose_name = 'Copy'\n        verbose_name_plural = 'Copies'\n        ordering = ['due_date']\n\n    # Model methods\n    def __str__(self):\n        return f'{self.id} ({self.book.title})'\n\n    @property\n    def overdue(self):\n        if self.due_date and date.today() > self.due_date:\n            return True\n        return False\n\n...\n\nclass BorrowedCopy(models.Model):\n    \"\"\"Defining a custom model to relate the borrowing of a book instance to a library patron\"\"\"\n    # Constants\n    # Length of time a book can be checked out for\n    CHECKOUT_DURATION = timedelta(days=14)\n    LATE_FEE = 0.5  # The per day fee assessed if a copy is late\n    # Fields\n    patron = models.ForeignKey(\n        User, on_delete=models.CASCADE, related_name='borrowed_books')\n    copy = models.ForeignKey(BookInstance, on_delete=models.CASCADE)\n    date_checked_out = models.DateField(null=True, blank=True)\n    due_date = models.DateField(null=True, blank=True)\n    date_returned = models.DateField(null=True, blank=True)\n    assessed_late_fee = models.FloatField(\n        verbose_name='Late Fee', null=True, help_text='Late fee assessed (if any)')\n\n    # Meta options\n    class Meta:\n        ordering = ('copy', )\n        verbose_name = 'Checkout History'\n        verbose_name_plural = 'Checkout History'\n\n    # Model methods\n    def save(self, *args, **kwargs):\n        \"\"\"Override default save method to set due date\"\"\"\n        logger.info(f'Calling model save method for {self}')\n        # We are going to use these records to hold reservations as well\n        # so we need to accomodate situations where date_checked_out = None\n        if self.date_checked_out and not self.due_date:\n            self.due_date = self.date_checked_out + self.CHECKOUT_DURATION\n            # This bit is redundant and I'll likely remove the due_date from\n            # the Instance model but for now, let's keep our data in sync\n            self.copy.due_date = self.due_date\n            self.copy.status = BookInstance.ON_LOAN\n            self.copy.save()\n        if self.date_returned and self.date_returned > self.due_date:\n            # Assigning late fee if returned after due date\n            self.assessed_late_fee = (self.date_returned -\n                                      self.due_date).days * self.LATE_FEE\n        super().save(*args, **kwargs)\n\n    @property\n    def late_fee(self):\n        \"\"\"Calculate and return late fee\"\"\"\n        if self.assessed_late_fee:\n            # If the book has been returned we have assessed the late fee and made it static\n            # The we just return the fee\n            return self.assessed_late_fee\n        elif self.due_date:\n            # If it hasn't been returned the late fee is dynamically calculated\n            td = date.today()\n            past_due = td - self.due_date\n            return past_due.days * self.LATE_FEE if past_due.days > 0 else 0\n        # If there's no due date it hasn't been chacked out yet (Reserved), nothing to see here\n        return None\n```\n","url":"https://supermanzer.github.io/DendronNotes/notes/1a9144d0-ac3f-48af-9db9-aee31546240b.html","relUrl":"notes/1a9144d0-ac3f-48af-9db9-aee31546240b.html"},{"doc":"Dependent Model Statuses","title":"Dependent Model Statuses","hpath":"localibrary.models.annotations","content":"\n# Models with Dependent Values in the Local Library\n\nMost of our models define pretty much all we need to ask of them. We can traverse relationships between `Book`, `Author`, and `BookInstance` models effectively. However there is one bit of functionality that I want to review. This is the status of the `BookInstance` model and it's relationship to the `BorrowedCopy` model. Specifically I want to address the somewhat complex nature of the `status` field in the `BookInstance` model.\n\n## Models in Question\n\nTo refresh, here are the model definitions, complete with `Meta` info and methods:\n\n![[localibrary.models.copy_borrowed]]\n\nWe can see there is an aweful lot of calculations and comparisons being carried out in the Python layer of the application. While this is fine in general and likely to not cause any issues on an application of this size, I still prefer to get in the habit of optimizing where I can. With that in mind I would like to utilize [Django Annotations](https://docs.djangoproject.com/en/3.1/ref/models/querysets/#annotate) to move more of these operations to the database layer. Let's take a look at a few different approaches to simplifying this approach.\n\n---\n","url":"https://supermanzer.github.io/DendronNotes/notes/ef98e148-df74-4d8b-a4e5-eb8d398c3b57.html","relUrl":"notes/ef98e148-df74-4d8b-a4e5-eb8d398c3b57.html"},{"doc":"Approaches","title":"Approaches","hpath":"localibrary.models.annotations.approaches","content":"\n## Workflow\n\nIn determining how I want to solve this problem I should first break down the workflow I envision for our `BookInstance` and `BorrowedCopy` records.\n\n- `BorrowedCopy` records represent the borrowing history of each copy but in certain situations repsent the current state of a copy.\n  - When `date_checked_out` has a value but `date_returned` does not, this indicates the copy is `ON_LOAN`.\n  - When both `date_checked_out` and `date_returned` are `NULL` this implies a reservation for a given copy.\n  - All creations of a `BorrowedCopy` record will be reservations (i.e. no `date_checked_out`) if the copy status is not `AVAILABLE`.\n- Library Patrons can create `BorrowedCopy` record for a given `BookInstance` that is in the `AVAILABLE`, `ON_LOAN`, or `RESERVED` status.\n- Only copies with a status of `AVAILABLE` can be checked out but reservation records can be created\n- Only Library Staff can change a `BookInstance` status from `ON_LOAN` to any other status. In effect, they are responsible for returning a book to circulation.\n- The presence or absence of a `BorrowedCopy` record without `date_checked_out` value for a given copy determines if it returns to an `AVAILABLE` or `RESERVED` status upon being returned to circulation.\n\n## Controlling `BookInstance` Status\n\nWriting out the workflow is a great exercise and typing the list above helped clarify a few things for me. Initially I was thinking I could create an annotation that evaluates any related `BorrowedCopy` records for a given `BookInstance` and return this as the default for the status. While this approach does have the benefit of always being the most up to date (since it is caclulated each time a record is acccessed) it also increases the complexity of the SQL generated to fetch our record. In this scenario the `status` field would cease to exist on the `BookInstance` model per se and only be returned as a dynamically caculated value.\n\nHowever, this approach cannot statisfy one of the requirements of the above workflow. That is that only Library staff can return a copy to circulation. This rules out the pure annotation approach since some changes in status are not controlled by related record values.\n\n### Static Fields Approach\n\nWhile we must rely on a static model field to get the functionality we want, we can still utilize a similar approach that moves more of the operations to the database layer. This will help make sure that the application can better scale as the library gets more popular or patrons getting into reservation wars for the most popular books.\n\nI'll use Django's nifty [Conditional Update](https://docs.djangoproject.com/en/3.1/ref/models/conditional-expressions/#conditional-update) approach. This allows me to specificy various criteria in When clauses that will be evaluated in the database and which value should be written to the status field depending on which clause returns `True`.\n\nNow where to put this little bit of logic? Well the returning to circulation operaton happens directly with the BookInstance model so it would seem that we need a model method to represent that action wherein we will place this logic. _However_ we also need to revise the logic in the `save()` method for the `BorrowedCopy` model to accurately reflect the intended workflow.\n\nIn order to avoid having to maintain multiple copies of the same logic I will use one of my favorite features of Django annotations. That is they can be defined and assigned to a variable, outside of calling the actual query. This means I can _hopefully_ create a single definition of this business logic and reuse it in multiple model methods.\n\n#### On Second Thought...\n\nWe'll need two versions of the conditional update annotation.\n\n- `status_patrons`: The one for library patrons will determine if it should set the copy's status to `ON_LOAN` (checking out), `RESERVED` (placing on hold), or `MAINTENANCE` (returned and awaiting library staff).\n- `status_staff`: The one for staff will determine if a copy should be set to `RESERVED` (if `BorrowedCopy` records without a checkout date exist) or `AVAILABLE` (if not) when it is returned to circulation (or taken out of `MAINTENANCE` status).\n\nThe benefit of this approach is we don't need to require either staff or patrons to know what the appropriate status to set for the copy is. Of course the front-end will determine whether to present a 'Check Out' or 'Reserve' button to the user (or both) for the patrons. For the staff, I will do a little bit of customizing the default Django admin interface to allow staff to 'Return to Circulation' for multiple copies at once.\n","url":"https://supermanzer.github.io/DendronNotes/notes/c874cfd9-6e98-431b-a86a-b60d0cbf3a69.html","relUrl":"notes/c874cfd9-6e98-431b-a86a-b60d0cbf3a69.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://supermanzer.github.io/DendronNotes/notes/changelog.html","relUrl":"notes/changelog.html"}]
