[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://supermanzer.github.io/DendronNotes/notes/403.html","relUrl":"notes/403.html"},{"doc":"Manzer's Notes","title":"Manzer's Notes","hpath":"root","content":"\n# Manzer Notes\n\nDendron root node for note vautls. The notes below will attempt to follow general project stucture but I suffer the same vicissitudes as many other creative invdividuals who have more ideas than they have space or time to place them in. Things get lost, stuff goes out of order. Eventually it'll drive me nuts enough to fix it but depending on when someone happens across this little adventure it note taking this may appear rather disorderly.\n\n## Projects\n\n- [[localibrary]] - A simple but complete full-stack web application replicating a local library site for patrons. It uses Django & DRF for the back-end and Nuxt.js for the front-end.\n","url":"https://supermanzer.github.io/DendronNotes","relUrl":"/"},{"doc":"Local Library","title":"Local Library","hpath":"localibrary","content":"\n<img src=\"/assets/images/github.png\" alt=\"Github Logo\" width=\"50\"/> [Github Repo](https://github.com/supermanzer/NuxtDRFMDN)\n\nThis project is a playground of sorts for various ideas and technologies I am curious about implementing in a web application. Often times I will find myself working through a tutorial while learning some new tech and find myself curious about how I would integrate it into a larger project. One of the points of developing the **Local Library** application is to have that larger project into which I can attempt to insert various technologies and application workflows I am curious about. The application built here is based upon the excellent [Django tutorial](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django) created by the bright folks at Mozilla Developer Network. This tutorial took me from a general, if basic, understanding of implementing Django to a level of mastery that made me confident I could build production software tools with it. It's become a core part of my goto toolkit when building database powered applcations.\n","url":"https://supermanzer.github.io/DendronNotes/notes/c49bdcee-daa2-4b8d-af33-af74f37173f0.html","relUrl":"notes/c49bdcee-daa2-4b8d-af33-af74f37173f0.html"},{"doc":"Nuxt - Front End","title":"Nuxt - Front End","hpath":"localibrary.nuxt","content":"\nThe user interface for library patrons is built using [Nuxt.js](https://nuxtjs.org) using an entirely static (JAMstack) approach. This is the most unfamiliar technology in the stack for me and the area of the steepest learning curve. Working on this pet project has given me enough understanding to begin to use this technology in my professional work.\n\n---\n\n## Features\n\n![[localibrary.nuxt.features]]\n\n## Current Status & Next Steps\n\n![[localibrary.nuxt.current-status]]\n","url":"https://supermanzer.github.io/DendronNotes/notes/84a5986a-2b11-4161-8a4e-7f107f2583c3.html","relUrl":"notes/84a5986a-2b11-4161-8a4e-7f107f2583c3.html"},{"doc":"Features - Current and Future","title":"Features - Current and Future","hpath":"localibrary.nuxt.features","content":"\nInterface features, workflows, and technologies.\n\n- [x] Authentication against back-end using [Django REST Framework Simple JWT](https://django-rest-framework-simplejwt.readthedocs.io/en/latest/) and [@nuxt/auth](https://auth.nuxtjs.org/).\n- [x] Registered patrons can check out a book that will be assigned to their checkout history.\n- [x] Registered patrons can see their checked out books, checkout history, and total late fees.\n- [ ] Allow a registered patron to return and book copy and update all necessary databse records.\n- [ ] Allow registered patrons to \"pay\" late fees and write this back to the database.\n- [ ] Allow patrons to create a reservation on a book copy not currently available.\n- [ ] Upon login, notify a patron if a book they have reserved is currently available for checkout.\n","url":"https://supermanzer.github.io/DendronNotes/notes/f02e4c76-8350-4f2c-b9cb-4830eb7625f7.html","relUrl":"notes/f02e4c76-8350-4f2c-b9cb-4830eb7625f7.html"},{"doc":"Current Status & Next Steps","title":"Current Status & Next Steps","hpath":"localibrary.nuxt.current-status","content":"\n### 3.27.2021\n\n---\n\nThe update queries are written to set the correct `status` of a `BookInstance` record have been written (see [[here|localibrary.models.dependent-status.approaches]]). The update to the related `BookInstance` record using the `status_patron` annotation has been included in the `save()` method of the `BorrowedCopy` data model. To complete the approach to using subqueries and annotations when dealing with the BookInstance, a custom filter and custom actions needs to be added to the default Django admin interface (which is currently how \"Library Staff\" interact with the database).\n","url":"https://supermanzer.github.io/DendronNotes/notes/856843c7-5881-4d05-becc-7ae2f6a6499d.html","relUrl":"notes/856843c7-5881-4d05-becc-7ae2f6a6499d.html"},{"doc":"Models","title":"Models","hpath":"localibrary.models","content":"\n","url":"https://supermanzer.github.io/DendronNotes/notes/ecde1434-0562-43bb-855b-fc9c7c5a4f29.html","relUrl":"notes/ecde1434-0562-43bb-855b-fc9c7c5a4f29.html"},{"doc":"Dependent Model Fields","title":"Dependent Model Fields","hpath":"localibrary.models.dependent-status","content":"\n# Models with Dependent Values in the Local Library\n\nMost of our models define pretty much all we need to ask of them. We can traverse relationships between `Book`, `Author`, and `BookInstance` models effectively. However there is one bit of functionality that I want to review. This is the status of the `BookInstance` model and it's relationship to the `BorrowedCopy` model. Specifically I want to address the somewhat complex nature of the `status` field in the `BookInstance` model.\n\n## Models in Question\n\nTo refresh, here are the model definitions, complete with `Meta` info and methods:\n\n![[localibrary.models.copy_borrowed]]\n\nWe can see there is an awful lot of calculations and comparisons being carried out in the Python layer of the application. While this is fine in general and likely to not cause any issues on an application of this size, I still prefer to get in the habit of optimizing where I can. With that in mind I would like to utilize [Django Annotations](https://docs.djangoproject.com/en/3.1/ref/models/querysets/#annotate) to move more of these operations to the database layer. Let's take a look at a few different approaches to simplifying this approach.\n\n---\n","url":"https://supermanzer.github.io/DendronNotes/notes/ef98e148-df74-4d8b-a4e5-eb8d398c3b57.html","relUrl":"notes/ef98e148-df74-4d8b-a4e5-eb8d398c3b57.html"},{"doc":"Fixing Copy Status","title":"Fixing Copy Status","hpath":"localibrary.models.dependent-status.approaches","content":"\n## Workflow\n\nIn determining how I want to solve this problem I should first break down the workflow I envision for our `BookInstance` and `BorrowedCopy` records.\n\n- `BorrowedCopy` records represent the borrowing history of each copy but in certain situations repsent the current state of a copy.\n  - When `date_checked_out` has a value but `date_returned` does not, this indicates the copy is `ON_LOAN`.\n  - When both `date_checked_out` and `date_returned` are `NULL` this implies a reservation for a given copy.\n  - All creations of a `BorrowedCopy` record will be reservations (i.e. no `date_checked_out`) if the copy status is not `AVAILABLE`.\n- Library Patrons can create `BorrowedCopy` record for a given `BookInstance` that is in the `AVAILABLE`, `ON_LOAN`, or `RESERVED` status.\n- Only copies with a status of `AVAILABLE` can be checked out but reservation records can be created for `ON_LOAN` and `RESERVED` copies.\n- Only Library Staff can change a `BookInstance` status from `ON_LOAN` to any other status. In effect, they are responsible for returning a book to circulation.\n- The presence or absence of a `BorrowedCopy` record without `date_checked_out` value for a given copy determines if it returns to an `AVAILABLE` or `RESERVED` status upon being returned to circulation.\n\n## Controlling `BookInstance` Status\n\nWriting out the workflow is a great exercise and typing the list above helped clarify a few things for me. Initially I was thinking I could create an annotation that evaluates any related `BorrowedCopy` records for a given `BookInstance` and return this as the default for the status. While this approach does have the benefit of always being the most up to date (since it is caclulated each time a record is acccessed) it also increases the complexity of the SQL generated to fetch our record. In this scenario the `status` field would cease to exist on the `BookInstance` model per se and only be returned as a dynamically caculated value.\n\nHowever, this approach cannot statisfy one of the requirements of the above workflow. That is that only Library staff can return a copy to circulation. This rules out the pure annotation approach since some changes in status are not controlled by related record values.\n\n### Static Fields Approach\n\nWhile we must rely on a static model field to get the functionality we want, we can still utilize a similar approach that moves more of the operations to the database layer. This will help make sure that the application can better scale as the library gets more popular or patrons getting into reservation wars for the most popular books.\n\nI'll use Django's nifty [Conditional Update](https://docs.djangoproject.com/en/3.1/ref/models/conditional-expressions/#conditional-update) approach. This allows me to specificy various criteria in When clauses that will be evaluated in the database and which value should be written to the status field depending on which clause returns `True`.\n\nNow where to put this little bit of logic? Well the returning to circulation operaton happens directly with the BookInstance model so it would seem that we need a model method to represent that action wherein we will place this logic. _However_ we also need to revise the logic in the `save()` method for the `BorrowedCopy` model to accurately reflect the intended workflow.\n\nIn order to avoid having to maintain multiple copies of the same logic I will use one of my favorite features of Django annotations. That is they can be defined and assigned to a variable, outside of calling the actual query. This means I can _hopefully_ create a single definition of this business logic and reuse it in multiple model methods.\n\n### On Second Thought...\n\nWe'll need two versions of the conditional update annotation.\n\n- `status_patrons`: The one for library patrons will determine if it should set the copy's status to `ON_LOAN` (checking out), `RESERVED` (placing on hold), or `MAINTENANCE` (returned and awaiting library staff).\n- `status_staff`: The one for staff will determine if a copy should be set to `RESERVED` (if `BorrowedCopy` records without a checkout date exist) or `AVAILABLE` (if not) when it is returned to circulation (or taken out of `MAINTENANCE` status).\n\nThe benefit of this approach is we don't need to require either staff or patrons to know what the appropriate status is to set for the copy. Of course the front-end will determine whether to present a 'Check Out' or 'Reserve' button to the user (or both) for the patrons. For the staff, I will do a little bit of [customizing the default Django admin interface](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/actions/) to allow staff to 'Return to Circulation' for multiple copies at once.\n\nIn this case I get to play with a few of the nifty advanced ORM features of Django. Let's take a look!\n\n### Annotations for Static Field Values\n\n- First I'm using the [`OuterRef` to nest subqueries](https://docs.djangoproject.com/en/3.1/ref/models/expressions/#subquery-expressions) within the overall `Case` statement. I will use these subqueries to define each of statuses.\n\n```python\n\"\"\"\n  catalog/annotations.py\n\"\"\"\n\nfrom django.db.models import OuterRef\nfrom catalog.models import BorrowedCopy\n# When using the OuterRef function, this annotation must be called as\n# part of a query on the related object, BookInstance in this case.\n\n# Define condition in which a copy is checked out.\nchecked_out = BorrowedCopy.objects.filter(\n  copy=OuterRef('pk'),\n  date_checked_out__isnull=False,\n  date_returned__isnull=True\n)\n# Define condition in which a copy is reserved\nreserved = BorrowedCopy.objects.filter(\n  copy=OuterRef('pk'),\n  date_checked_out__isnull=True\n)\n```\n\n- Next we roll up each of these subqueries inside a Case statement. To make this simple as well as provide some potential query optimization, I will be applying the [`Exists` subquery class](https://docs.djangoproject.com/en/3.1/ref/models/expressions/#exists-subqueries) along with the rest of the `Case..When` functionality that are part of Django ORM's [conditional expressions](https://docs.djangoproject.com/en/3.1/ref/models/conditional-expressions/#) toolbox.\n\n```python\n\"\"\"\n  catalog/annotations.py\n\"\"\"\n...\nfrom django.db.models import Value, CharField, Case, When\nfrom catalog.models import BookInstance\n\nstatus_patrons = Case(\n  When(Exists(checked_out), then=Value(BookInstance.ON_LOAN)),\n  When(Exists(reserved), then=Value(BookInstance.RESERVED)),\n  default=Value(BookInstance.MAINTENANCE),\n  output_field=CharField()\n)\n\nstatus_staff = Case(\n  When(Exists(reserved), then=Value(BookInstance.RESERVED)),\n  default=Value(BookInstance.AVAILABLE),\n  output_field=CharField()\n)\n```\n\nThe `When` clause expects a dynamic value as the `then` keyword argument so to get this working as expected we wrap our static status values in the `Value` class. This ensures we write back \"o\" for `ON_LOAN` rather than go looking for a field called \"o\".\n\nThe `Case` statement will evaluate each `When` clause in order so even if a book being checked out has other future reservations, the `status_patrons` clause will still return the character value designating the status as \"on loan\". This is another example of why I like to declare each statically define choice to it's own static variable on the model (take a look at the BookInstance definition [[here|localibrary.models.copy_borrowed]] if you need a refresher). It means there is a single source of truth when it comes to static values in the application.\n\n### Implementing Annotation + Static Field Approach\n\nAlright, I think I've got my subqueries and annotations worked out. Now to plug them into the application workflow. For the patrons this is pretty simple. We just replace the setting of the status field from a manual value to using the query result defined above:\n\n```python\ndef save(self, *args, **kwargs):\n        \"\"\"Override default save method to set due date and update copy status\"\"\"\n        logger.info(f'Calling model save method for {self}')\n        from .annotations import status_patrons\n        BookInstance.objects.filter(pk=self.copy.id).update(\n            status=status_patrons\n        )\n        # We are going to use these records to hold reservations as well\n        # so we need to accomodate situations where date_checked_out = None\n        if self.date_checked_out and not self.due_date:\n            self.due_date = self.date_checked_out + self.CHECKOUT_DURATION\n        if self.date_returned and self.date_returned > self.due_date:\n            # Assigning late fee if returned after due date\n            self.assessed_late_fee = (self.date_returned -\n                                      self.due_date).days * self.LATE_FEE\n        super().save(*args, **kwargs)\n\n```\n\nYou can compare this to the previous `save()` method [[here|localibrary.models.copy_borrowed]] to see the difference but here's the plain english version. We import the query (doing it within the method to avoid circular import issues) and update the related copy. We use the `.filter()` approach because the `update()` functionality belongs to the `Queryset` object, not an individual record. Additionally the `status_patrons` includes a `Subquery` clause so it needs to be placed within an outer query in order to operate as expected. Since the decision of what status should be assigned is handled by the query we get to call this without doing any `if...else` checks first. That is still done to set due_dates and late fees. At some point I might look into streamlining that. But for now this does the trick. Since both checking out and returning book actions in the front-end trigger the `save()` method for the `BorrowedCopy` model, this handles both actions nicely.\n\nNow let's take a look at the implementation of the staff workflow. This makes use of one of the coolest features of the [Django admin site](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/). That is the amazing amount of customization that is possible. The admin site comes with basic CRUD functionality built in, assuming you have properly registered any custom models in the autogenerated `admin.py` file. Since I've decided that library staff would be using the Django admin site, this means we just need to add one additional option to the `BookInstance` model. And it's **super** easy! Let's take a look:\n\nI like to keep functionality encapsulated so I create a separate file:\n\n```python\n\"\"\"\n    catalog/admin_functions.py\n\n    Creating custom funcionality to be added to the Django admin site.\n    https://docs.djangoproject.com/en/3.1/ref/contrib/admin/actions/\n\n    Function(s):\n    * return_to_circulation:  Sets `BookInstance` status based on `BorrowedCopy` subquery results\n\"\"\"\n\nfrom .annotations import status_staff\n\n\ndef return_to_circulation(modeladmin, request, queryset):\n    \"\"\"\n    Assign correct `status` value to `BookInstance` based on `BorrowedCopy` subquery\n\n    Args:\n        modeladmin (ModelAdmin): ModelAdmin objeect for `BookInstance`\n        request (HttpRequest): HttpRequest object\n        queryset (Queryset): Queryset object of `BookInstance` records to be modified.\n    \"\"\"\n    queryset.update(status=status_staff)\n\n\n# Adding a more helpful descrption to be rendered in the admin interface\nreturn_to_circulation.short_description = 'Return copies to circulation'\n```\n\nWhen I said this was super easy, I wasn't kidding. There are lots of comments so it may look like more is going on here but essentially `queryset.update(status=status_staff)` is all we need to do. Everything else is just good housekeeping. Now how do we assign this functionality to our admin site? In the `admin.py` file of course! More specifically, the `InstanceAdmin` class definition.\n\n```python\ncatalog/admin.py\nfrom .admin_functions import return_to_circulation\n...\nclass InstanceAdmin(admin.ModelAdmin):\n    ...\n    actions = [return_to_circulation, ]  # yes it's really this simple\n    ...\n```\n\nAfter these changes are saved library staff can update returned books to the correct status in bulk. Let's think about how cool that is for a second. A tired librarian could come in on Monday to find hundreds of books returned and awaiting return to circulation. Rather than having to look at each record and see if there are any pending reservations before updating the status of each book copy, the staff member could simple \"Select All\" and update the status. I think that's pretty damn nifty.\n\n<img src=\"/DendronNotes/assets/images/update.png\" alt=\"Update Admin Action\" width=\"800\"/>\n","url":"https://supermanzer.github.io/DendronNotes/notes/c874cfd9-6e98-431b-a86a-b60d0cbf3a69.html","relUrl":"notes/c874cfd9-6e98-431b-a86a-b60d0cbf3a69.html"},{"doc":"Book Instance and Borrowed Copy Models","title":"Book Instance and Borrowed Copy Models","hpath":"localibrary.models.copy_borrowed","content":"\n```python\nclass BookInstance(models.Model):\n    \"\"\"Model representing a specific copy of a book\"\"\"\n    # CONSTANTS - I FIND THIS APPROACH USEFUL EVEN THOUGH IT SEEMS REDUNDANT\n    MAINTENANCE = 'm'\n    ON_LOAN = 'o'\n    AVAILABLE = 'a'\n    RESERVED = 'r'\n\n    LOAN_STATUS = (\n        (MAINTENANCE, 'Maintenance'),\n        (ON_LOAN, 'On loan'),\n        (AVAILABLE, 'Available'),\n        (RESERVED, 'Reserved')\n    )\n    # FIELDS\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4,\n                          help_text='Unique ID for particular book')\n    book = models.ForeignKey(\n        'Book', on_delete=models.RESTRICT, related_name='instances')\n    imprint = models.CharField(max_length=200)\n    due_date = models.DateField(null=True, blank=True)\n    status = models.CharField(max_length=1, choices=LOAN_STATUS,\n                              blank=True, default=MAINTENANCE, help_text='Book availability')\n    # Meta options\n\n    class Meta:\n        verbose_name = 'Copy'\n        verbose_name_plural = 'Copies'\n        ordering = ['due_date']\n\n    # Model methods\n    def __str__(self):\n        return f'{self.id} ({self.book.title})'\n\n    @property\n    def overdue(self):\n        if self.due_date and date.today() > self.due_date:\n            return True\n        return False\n\n...\n\nclass BorrowedCopy(models.Model):\n    \"\"\"Defining a custom model to relate the borrowing of a book instance to a library patron\"\"\"\n    # Constants\n    # Length of time a book can be checked out for\n    CHECKOUT_DURATION = timedelta(days=14)\n    LATE_FEE = 0.5  # The per day fee assessed if a copy is late\n    # Fields\n    patron = models.ForeignKey(\n        User, on_delete=models.CASCADE, related_name='borrowed_books')\n    copy = models.ForeignKey(BookInstance, on_delete=models.CASCADE)\n    date_checked_out = models.DateField(null=True, blank=True)\n    due_date = models.DateField(null=True, blank=True)\n    date_returned = models.DateField(null=True, blank=True)\n    assessed_late_fee = models.FloatField(\n        verbose_name='Late Fee', null=True, help_text='Late fee assessed (if any)')\n\n    # Meta options\n    class Meta:\n        ordering = ('copy', )\n        verbose_name = 'Checkout History'\n        verbose_name_plural = 'Checkout History'\n\n    # Model methods\n    def save(self, *args, **kwargs):\n        \"\"\"Override default save method to set due date\"\"\"\n        logger.info(f'Calling model save method for {self}')\n        # We are going to use these records to hold reservations as well\n        # so we need to accomodate situations where date_checked_out = None\n        if self.date_checked_out and not self.due_date:\n            self.due_date = self.date_checked_out + self.CHECKOUT_DURATION\n            # This bit is redundant and I'll likely remove the due_date from\n            # the Instance model but for now, let's keep our data in sync\n            self.copy.due_date = self.due_date\n            self.copy.status = BookInstance.ON_LOAN\n            self.copy.save()\n        if self.date_returned and self.date_returned > self.due_date:\n            # Assigning late fee if returned after due date\n            self.assessed_late_fee = (self.date_returned -\n                                      self.due_date).days * self.LATE_FEE\n        super().save(*args, **kwargs)\n\n    @property\n    def late_fee(self):\n        \"\"\"Calculate and return late fee\"\"\"\n        if self.assessed_late_fee:\n            # If the book has been returned we have assessed the late fee and made it static\n            # The we just return the fee\n            return self.assessed_late_fee\n        elif self.due_date:\n            # If it hasn't been returned the late fee is dynamically calculated\n            td = date.today()\n            past_due = td - self.due_date\n            return past_due.days * self.LATE_FEE if past_due.days > 0 else 0\n        # If there's no due date it hasn't been chacked out yet (Reserved), nothing to see here\n        return None\n```\n","url":"https://supermanzer.github.io/DendronNotes/notes/1a9144d0-ac3f-48af-9db9-aee31546240b.html","relUrl":"notes/1a9144d0-ac3f-48af-9db9-aee31546240b.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://supermanzer.github.io/DendronNotes/notes/changelog.html","relUrl":"notes/changelog.html"}]
